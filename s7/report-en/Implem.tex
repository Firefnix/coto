\chapter{Implementation}
\label{ch:Implementation}

The implementation was written in \textbf{C++}. This choice was motivated by several factors: performance, the maturity of the language and its use in several historical projects in the field \cite{Bichsel_2023} \cite{QTranslator}, and its proximity to the well-known C language.

\section{Structure du code}

The code is the subject of extensive documentation, available online. \cite{Leroy_doc}
The implementation makes extensive use of \textbf{object-oriented programming}, defining classes for the objects handled.
Some of the main classes are as follows, from lowest to highest level:
\begin{itemize}
  \item Real intervals (any, of positive reals or modulo $2\pi$), and complex intervals (Cartesian or polar)
  \item \textbf{Diagrams} (by default, additive and abstract)
  \item Branches, which contain a link (\textbf{pointer}) to a destination digram and a complex interval (Cartesian or polar)
\end{itemize}

Classes and functions are organized in \textbf{namespaces} to avoid name conflicts, and defined in separate files. \textbf{reduction} functions are then used to reduce diagrams, using selection functions.

The definition of functions and methods and their implementation are separated into header files and source code files, respectively. To take advantage of \textbf{separate compilation}, header files are included in source code files, and source code files are compiled into static libraries.

During this semester, an effort was made to improve \textbf{interchangeability} between Cartesian and polar intervals, and to make the code more generic, for example by defining adapted and optimized types for gate matrices or states (containing complexes or intervals).

\section{Tests}

To guarantee code quality, \textbf{unit tests} have been written for most functions and methods. These tests are written using the open-source \textit{Google Test} library, and are organized into \textbf{test suites} for each class. \cite{GoogleTest} The 46 tests, which run in less than half a second and include several thousand assertions, are used to validate code and detect bugs or regressions.

\section{QASM interpreter}

An \textbf{interpreter} for the Open QASM language was developed during this semester. It can be used to read a QASM file defining qubits and applying quantum gates to them, generate a diagram and make the modifications corresponding to the gates you wish to apply to it, and display the evaluation.

This interpreter can also operate in interactive mode, i.e. reading instructions from standard input. It does not support all QASM instructions, only basic logic gates ($X$, $H$, $CX$, $S$, phase gates). However, this interpreter's \textit{back-end} is capable of applying any gate using the method detailed in \autoref{sec:Portes}. This interpreter consists of a library that can be included with the header \texttt{qasm.h} including a \texttt{qasm} namespace and an \texttt{prompt} executable.

As QASM is already a quantum circuit description language, oppositely to a high-level programming language, it was not considered necessary to build a true compiler comprising a front-end, a middle-end performing optimizations and a back-end transforming the intermediate representation into an executable. The interpreter has been successfully tested on several examples of quantum circuits.

The example program \ref{lst:QASM} runs in 2.6 ms. \textbf{benchmarks} on a larger number of qubits, or on more complex circuits, have not been carried out. Furthermore, it is likely that a significant part of the execution time is due to reading the file or interpreting the QASM, and not to generating the diagram and modifying it.

\section{Tools}

The source code is versioned using \textit{Git}, and is available on the \textit{GitHub} platform. \cite{Git} \cite{GitHub} \cite{Leroy_2025} This project is the subject of a \textbf{continuous integration} using \textit{GitHub Actions}, automating test validation.

This semester saw the arrival of \textit{Clang} as a compiler instead of \textit{GCC}, and \textit{Ninja} instead of \textit{Make}. \cite{Clang} \cite{Ninja}
These changes have reduced compilation time and improved the readability of error messages, as well as facilitating the use of recent language features (dating back to C++23).
These tools are orchestrated by \textit{CMake}. \cite{CMake}

Compiling the project (excluding tests) takes about 8 seconds on a recent laptop. It takes a further 5 seconds to compile the tests. The project has around 5,000 lines of code, including around 1,000 lines of tests.

The project is also the subject of a \textbf{documentation}, written in the comments of the header files. Documentation web pages are automatically generated by \textit{Doxygen}. \cite{Doxygen} and automatically published on \textit{GitHub Pages} each time they are modified using \textit{GitHub Actions}. \cite{Leroy_doc}